defmodule Ion.Parse.BinaryTest do
  use ExUnit.Case
  doctest Ion.Parse.Binary

  describe "plain binary" do
    test "null" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x0F>>)
    end

    test "null.null" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x0F>>)
    end

    test "null.bool" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x1F>>)
    end

    test "null.int" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x3F>>)
    end

    test "null.float" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x4F>>)
    end

    test "null.decimal" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x5F>>)
    end

    test "null.timestamp" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x6F>>)
    end

    test "null.symbol" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x7F>>)
    end

    test "null.string" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x8F>>)
    end

    test "null.clob" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x9F>>)
    end

    test "null.blob" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0xAF>>)
    end

    test "null.list" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0xBF>>)
    end

    test "null.sexp" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0xCF>>)
    end

    test "null.struct" do
      assert {:ok, nil} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0xDF>>)
    end

    test "boolean false" do
      assert {:ok, false} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x10>>)
    end

    test "boolean true" do
      assert {:ok, true} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x11>>)
    end

    test "integer 1" do
      assert {:ok, 1} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x21, 0x1>>)
    end

    test "integer 0" do
      assert {:ok, 0} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x20>>)
    end

    test "integer -1" do
      assert {:ok, -1} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x31, 0x1>>)
    end

    test "integer 123456" do
      assert {:ok, 123_456} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x23, 0x1, 0xE2, 0x40>>)
    end

    test "integer -123456" do
      assert {:ok, -123_456} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x33, 0x01, 0xE2, 0x40>>)
    end

    test "float 0e0" do
      assert {:ok, 0.0} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x40>>)
    end

    test "float -0e0" do
      assert {:ok, -0.0} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>)
    end

    test "float 1.0e0" do
      assert {:ok, 1.0} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x48, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>)
    end

    test "float -0.12e4" do
      assert {:ok, -1200.0} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x48, 0xC0, 0x92, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00>>)
    end

    test "float ∞" do
      assert {:ok, :infinity} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x48, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>)
    end

    test "float -∞" do
      assert {:ok, :neg_infinity} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x48, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>)
    end

    test "float NaN" do
      assert {:ok, :nan} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x48, 0x7F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>)
    end

    test "decimal 0D0" do
      assert {:ok, 0.0} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x50>>)
    end

    test "decimal -0D0" do
      assert {:ok, 0.0} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x52, 0x80, 0x80>>)
    end

    test "decimal 1.0D0" do
      assert {:ok, 1.0e-64} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x52, 0xC1, 0xA>>)
    end

    test "decimal -0.12D4" do
      assert {:ok, -0.12} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x52, 0x82, 0x8C>>)
    end

    test "decimal 123456.789012" do
      assert {:ok, 123_456.789012} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x56, 0xC6, 0x1C, 0xBE, 0x99, 0x1A, 0x14>>)
    end

    test "decimal -123456.789012" do
      assert {:ok, -123_456.789012} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x56, 0xC6, 0x9C, 0xBE, 0x99, 0x1A, 0x14>>)
    end

    test "decimal 12,345,678,901,234,567,890.12345678901234567890" do
      assert {:ok, 12_345_678_901_234_567_890.12345678901234567890} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x5E, 0x92, 0xD4, 0x03, 0xA0, 0xC9, 0x20, 0x75, 0xC0, 0xDB, 0xF3, 0xB8, 0xAC, 0xBC, 0x5F, 0x96, 0xCE, 0x3F, 0xA, 0xD2>>)
    end

    test "decimal -12,345,678,901,234,567,890.12345678901234567890" do
      assert {:ok, -12_345_678_901_234_567_890.12345678901234567890} = Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x5E, 0x92, 0xD4, 0x83, 0xA0, 0xC9, 0x20, 0x75, 0xC0, 0xDB, 0xF3, 0xB8, 0xAC, 0xBC, 0x5F, 0x96, 0xCE, 0x3F, 0xA, 0xD2>>)
    end

    # 1.2345678901234568e308 is max exponent representable in the EVM
    test "decimal superhuge" do
      assert {:ok, 123_456_789_012_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_123_456_789_012_345} =
               Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x2E, 0xC5, 0x02, 0x24, 0xD4, 0x4E, 0x0C, 0x56, 0xF5, 0x37, 0x63, 0x28, 0x15, 0xF2, 0x50, 0x10, 0x16, 0xAA, 0x7C, 0x11, 0xF1, 0x5C, 0x2F, 0xB7, 0x29, 0xE9, 0xBE, 0x12, 0x49, 0xBC, 0xE8, 0x2D, 0x42, 0x46, 0xF3, 0x69, 0xCC, 0xE2, 0xD5, 0x50, 0x39, 0xC6, 0x2B, 0x56, 0x1E, 0xD7, 0xDD, 0x9F, 0xBF, 0x59, 0xA7, 0xC0, 0x7D, 0x86, 0x0B, 0xAE, 0xA6, 0x10, 0x0C, 0x7F, 0x10, 0x18, 0x90, 0xCC, 0x02, 0xBC, 0x74, 0xF1, 0xE2, 0xDF, 0x79>>)
    end

    test "decimal -superhuge" do
      assert {:ok, -123_456_789_012_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_123_456_789_012_345_678_901_234_567_890_123_456_789_012_345} =
               Ion.parse(<<0xE0, 0x01, 0x00, 0xEA, 0x3E, 0xC5, 0x02, 0x24, 0xD4, 0x4E, 0x0C, 0x56, 0xF5, 0x37, 0x63, 0x28, 0x15, 0xF2, 0x50, 0x10, 0x16, 0xAA, 0x7C, 0x11, 0xF1, 0x5C, 0x2F, 0xB7, 0x29, 0xE9, 0xBE, 0x12, 0x49, 0xBC, 0xE8, 0x2D, 0x42, 0x46, 0xF3, 0x69, 0xCC, 0xE2, 0xD5, 0x50, 0x39, 0xC6, 0x2B, 0x56, 0x1E, 0xD7, 0xDD, 0x9F, 0xBF, 0x59, 0xA7, 0xC0, 0x7D, 0x86, 0x0B, 0xAE, 0xA6, 0x10, 0x0C, 0x7F, 0x10, 0x18, 0x90, 0xCC, 0x02, 0xBC, 0x74, 0xF1, 0xE2, 0xDF, 0x79>>)
    end

    test "simple timestamp" do
      assert {:ok, %Date{year: 2000, month: nil, day: nil}} = Ion.parse(<<
        0xE0, 0x01, 0x00, 0xEA,
        # Timestamp type, length 3 bytes
        0x63,
        # varuint 0 offset, varuint year 2000
        0xC0, 0x0F, 0xD0
      >>)
    end

    test "large timestamp" do
      assert {:ok, %DateTime{day: 1, hour: 0, microsecond: {0, 0}, minute: 0, month: 1, second: 0, std_offset: 0, time_zone: "", utc_offset: 0, year: 2000, zone_abbr: ""}} = Ion.parse(<< # 2000-01-01T00:00:00.00Z
        0xE0, 0x01, 0x00, 0xEA,
        # Timestamp type of length 10
        0x6A, 0x80, 0x0F, 0xD0,
        0x81, 0x81, 0x80, 0x80,
        0x80, 0xC2, 0x0
      >>)
    end

    test "symbol" do
      assert {:ok, "symbol"} = Ion.parse(<<
        0xE0, 0x01, 0x00, 0xEA,
        # Annotation of length 12
        0xEC,
        # Annot length 1, annot = 3 ($ion_symbol_table)
        0x81, 0x83,
        # Start value of annotation, struct length 9
        0xD9,
        # symbols list identifier
        0x87,
        # list length 7 bytes
        0xB7,
        # string length 6
        0x86,
        # "symbol"
        0x73, 0x79, 0x6D, 0x62,
        0x6F, 0x6C, # End value of annotation
        # Symbol type length 1
        0x71,
        # Value: 10 referencing the first symbol in symbol table, "symbol"
        0xA
      >>)
    end

    test "struct" do
      # {}
      assert {:ok, %{}} == Ion.parse(<<0xE0, 0x1, 0x0, 0xEA, 0xD0>>)
    end

    test "struct with key/value" do
      # {a: true}
      assert {:ok, %{"a" => true}} == Ion.parse(<<
        0xE0, 0x01, 0x00, 0xEA,
        # Annotation of length 7, annot_length = 1, annot = 3
        0xE7, 0x81, 0x83,
        # Start value of annotation, struct length 4
        0xD4,
        # symbols list identifier
        0x87,
        # list of length 2 bytes
        0xB2,
        # string length 1
        0x81,
        # End annotation value, "a"
        0x61,
        # struct length 2
        0xD2,
        # field name
        0x8A,
        # value: true
        0x11
      >>)
    end

    test "annotation" do
      assert {:ok, {:annotation, ["an_annotation"], %{}}} == Ion.parse(<< # an_annotation::{}
        0xE0, 0x01, 0x00, 0xEA,
        0xEE, 0x95, 0x81, 0x83,
        0xDE, 0x91, 0x87, 0xBE,
        0x8E, 0x8D, 0x61, 0x6E,
        0x5F, 0x61, 0x6E, 0x6E,
        0x6F, 0x74, 0x61, 0x74,
        0x69, 0x6F, 0x6E, 0xE3,
        0x81, 0x8A, 0xD0>>)
    end
  end

  describe "files" do
    test "all types ungzipped" do
      assert {:ok, [
        {:annotation, ["metadata"],
          %{
            "data_blocks" => 2,
            "date" => %DateTime{year: 2007, month: 2, day: 23, hour: 12, minute: 14, second: 00, microsecond: {0, 0}, utc_offset: 0, time_zone: "", zone_abbr: "", std_offset: 0},
            "day_precision" => ~D[2007-01-01],
            "milliseconds" => %DateTime{year: 2007, month: 2, day: 23, hour: 20, minute: 14, second: 33, microsecond: {0, 0}, utc_offset: -99, time_zone: "", zone_abbr: "", std_offset: -99},
            "month_precision" => %Date{year: 2007, month: 1, day: nil},
            "string" => "test data with unicode ሴ and \"quotes\"",
            "symbol" => "some symbol",
            "utc" => %DateTime{year: 2007, month: 2, day: 23, hour: 20, minute: 14, second: 33, microsecond: {0, 0}, utc_offset: 0, time_zone: "", zone_abbr: "", std_offset: 0},
            "xml" => {:annotation, ["xml"], "<e a='v'>c</e>"},
            "year_precision" => %Date{year: 2007, month: nil, day: nil}
          }
        },
        {:annotation, ["data"],
          %{

          }
        },
        {:annotation, ["data"],
          %{

          }
        }
      ]} == Ion.parse_file("test/fixtures/all_types_binary.ion")
    end
  end
end
